# options.c 分支覆盖分析与测试计划

## 1. 当前覆盖率情况

根据覆盖率报告：
- **行覆盖率**: 119/313 (38.0%)
- **分支覆盖率**: 63/260 (24.2%)

## 2. 未覆盖代码区域分析

### 2.1 config_read_line() 函数未覆盖分支

#### 分支1: 单个引号处理（行50, 54）
```c
if (second_quote)
    second_quote[1] = '\0';
else  // 未覆盖
    str[0] = '\0';
```
**触发条件**: 配置行中只有一个引号（格式错误）
**当前状态**: Branch 1 not taken

### 2.2 create_options() 函数未覆盖区域

#### directory 配置块处理（行74-94）
**全部未覆盖**，包括：
- directory 块的识别
- directory 路径的解析
- 递归调用 create_options() 处理目录选项

**触发条件**: 配置文件中有 `directory "/path" { ... }` 块

### 2.3 expand_groups() 函数（行127-177）

**完全未覆盖**，包括：
- 遍历配置的组
- 解析组成员（用户和组）
- 通过 `@uid` 或 `@groupname` 引用系统组
- 通过 UID 或用户名解析用户
- 构建组和用户列表

**触发条件**: 
1. 配置文件中有 `group groupname { ... }` 块
2. 组块中定义了成员

### 2.4 config_init() 函数未覆盖区域

#### 错误处理分支
- **行192-194**: 配置文件打开失败的处理（未覆盖）
- **行217-221**: 内存分配失败的处理（未覆盖）
- **行224-229**: strdup 失败的处理（未覆盖）
- **行238-243**: group 块内存分配失败的处理（未覆盖）

#### 配置格式处理分支
- **行201-206**: 各种空格格式的替换
  - `" {` → `{` (部分覆盖)
  - `"{ "` → `"{"` (未覆盖)
  - `" }"` → `"}"` (未覆盖)
  - `"} "` → `"}"` (未覆盖)

#### group 配置块处理（行232-250）
**完全未覆盖**，包括：
- group 块的识别
- 组名的解析
- 组成员列表的保存

**触发条件**: 配置文件中有 `group groupname { ... }` 块

### 2.5 getoption() 函数

**已基本覆盖**，但有一些边界条件：
- 行266: `if (opt->name)` 的分支1（name 为 NULL）未覆盖

### 2.6 getoption_directories() 函数（行274-304）

**完全未覆盖**，包括：
- 当前目录路径的获取
- 目录列表的遍历
- 最长匹配目录的查找
- 目录特定选项的返回

**触发条件**:
1. 配置文件中有 directory 块
2. 当前工作目录匹配某个 directory 路径
3. 查询该目录的选项

### 2.7 user_is_in_group() 函数（行306-329）

**完全未覆盖**，包括：
- 检查用户是否在组的用户列表中
- 检查用户的主组是否匹配
- 检查用户是否在组的成员列表中

**触发条件**:
1. 配置文件中有 group 块
2. 用户属于某个组
3. 查询组相关的选项

### 2.8 getoption_group() 函数（行332-346）

**完全未覆盖**，包括：
- 遍历所有配置的组
- 检查用户是否在组中
- 查询组级别的选项和目录选项

**触发条件**:
1. 配置文件中有 group 块
2. 用户属于某个组
3. 查询组相关的选项

### 2.9 getoption_user() 函数

**已覆盖**，但 `getoption_directories()` 调用部分未覆盖

### 2.10 config_getoption() 函数

**基本覆盖**，但组和用户相关的目录选项查询未覆盖

### 2.11 config_getoption_reread() 函数（行412-422）

**完全未覆盖**

**触发条件**: `Reread_Config_File()` 函数调用此函数

### 2.12 Reread_Config_File() 函数（行432-523）

**完全未覆盖**，包括：
- 打开配置文件
- 逐行读取配置文件
- 识别可重载的选项（HELLO_STRING, QUIT_MSG 等）
- 更新选项值
- 重置数值选项

**触发条件**: 接收 SIGHUP 信号（通过 `handler_sighup()` 调用）

## 3. 挑战与限制

### 3.1 配置文件限制

**关键限制**: FTP fuzzing 的测试用例无法直接修改配置文件内容。配置文件在服务器启动时读取，且：
- `config_init()` 在服务器启动时调用
- 配置文件路径通过命令行参数 `-c` 指定
- 在 fuzzing 过程中，配置文件内容无法通过 FTP 命令改变

### 3.2 可触发的场景

以下场景可以通过 FTP 命令间接触发：

1. **目录特定选项查询**:
   - 如果配置文件中有 directory 块
   - 通过 `CWD` 命令切换到匹配的目录
   - 服务器会查询该目录的选项（可能触发 `getoption_directories()`）

2. **组相关选项查询**:
   - 如果配置文件中有 group 块
   - 用户属于某个组
   - 服务器在查询选项时会检查组选项（可能触发 `getoption_group()`）

3. **配置重读**:
   - 通过发送 SIGHUP 信号（但在 fuzzing 中无法直接发送信号）

### 3.3 无法直接触发的场景

以下场景在 FTP fuzzing 中难以触发：

1. **配置文件格式错误**（单个引号等）
2. **directory 配置块的处理**（需要修改配置文件）
3. **group 配置块的处理**（需要修改配置文件）
4. **expand_groups() 函数**（需要 group 配置）
5. **Reread_Config_File() 函数**（需要 SIGHUP 信号）
6. **错误处理分支**（文件打开失败、内存分配失败等）

## 4. 测试策略

### 4.1 策略1: 使用不同的配置文件

**方案**: 创建多个包含不同配置的配置文件，在不同的测试运行中使用不同的配置：

1. **包含 directory 块的配置**:
   ```
   global {
     ...
   }
   directory "/home/ubuntu/ftpshare/data" {
     DENY_LOGIN="no"
     DO_CHROOT="no"
   }
   ```

2. **包含 group 块的配置**:
   ```
   global {
     ...
   }
   group testgroup {
     @ubuntu
     ubuntu
   }
   ```

3. **包含格式问题的配置**:
   ```
   global {
     OPTION="value  # 单个引号情况
   }
   ```

**限制**: 这需要在 fuzzing 之前准备多个配置文件，且需要手动切换

### 4.2 策略2: 通过 FTP 命令触发已配置的功能

虽然无法直接控制配置文件，但可以通过 FTP 命令来触发使用配置选项的代码路径：

1. **触发目录选项查询**:
   - 使用 `CWD` 命令切换到不同目录
   - 如果配置中有 directory 块，可能触发相关代码

2. **触发组选项查询**:
   - 使用不同的用户登录
   - 如果用户属于配置的组，可能触发组选项查询

3. **触发全局选项查询**:
   - 执行各种 FTP 命令
   - 服务器会查询全局选项

### 4.3 策略3: 组合测试

创建测试用例组合：
1. 不同的 FTP 命令序列
2. 不同的目录操作
3. 不同的用户身份

## 5. 建议的测试用例设计

### 5.1 针对目录选项的测试用例

#### 用例1: 目录切换序列
```
USER ubuntu
PASS ubuntu
CWD /home/ubuntu/ftpshare
PWD
CWD /home/ubuntu/ftpshare/data
PWD
LIST
CWD ..
PWD
QUIT
```

#### 用例2: 深层目录切换
```
USER ubuntu
PASS ubuntu
CWD /home/ubuntu/ftpshare/data/subdir1
CWD subdir2
PWD
LIST
CWD /home/ubuntu/ftpshare
PWD
QUIT
```

### 5.2 针对组选项的测试用例

#### 用例3: 多用户测试
```
USER ubuntu
PASS ubuntu
SYST
QUIT
```
（需要确保用户属于配置的组）

### 5.3 针对全局选项的测试用例

#### 用例4: 选项相关的命令序列
```
USER ubuntu
PASS ubuntu
SYST
FEAT
QUIT
```

### 5.4 针对配置重读的测试用例

**注意**: 这需要外部信号，无法通过 FTP 命令直接触发

## 6. 预期覆盖情况

### 6.1 可覆盖的场景（通过 FTP 命令）

- ✅ 已覆盖的基本选项查询
- ⚠️ 目录特定选项（需要配置文件中有 directory 块）
- ⚠️ 组相关选项（需要配置文件中有 group 块）

### 6.2 难以覆盖的场景

- ❌ 配置文件格式错误处理
- ❌ directory 配置块的解析
- ❌ group 配置块的解析
- ❌ expand_groups() 函数
- ❌ Reread_Config_File() 函数
- ❌ 错误处理分支（内存分配失败等）

## 7. 建议

### 7.1 短期方案（FTP fuzzing 范围内）

1. **创建更多目录操作测试用例**:
   - 不同深度的目录切换
   - 各种目录路径组合

2. **创建更多选项相关的测试用例**:
   - 触发各种配置选项的查询
   - 组合不同的命令序列

### 7.2 长期方案（超出 FTP fuzzing 范围）

1. **创建专门的配置文件测试工具**:
   - 直接测试配置文件解析
   - 测试各种配置格式

2. **集成配置测试到测试框架**:
   - 使用不同的配置文件运行测试
   - 自动化配置切换

3. **使用符号执行或静态分析**:
   - 分析未覆盖的分支
   - 生成针对性的测试用例

## 8. 总结

`options.c` 文件的大量未覆盖代码与配置文件内容相关，而这些在 FTP fuzzing 中难以直接控制。主要未覆盖的区域包括：

1. **配置文件解析的特殊情况**（directory, group 块）
2. **错误处理分支**（很难触发）
3. **配置重读功能**（需要信号触发）

**建议**: 
1. 在 FTP fuzzing 范围内，创建更多目录操作和选项查询相关的测试用例
2. 考虑创建专门的配置文件测试工具来覆盖解析相关的代码
3. 接受某些分支在 FTP fuzzing 场景下难以覆盖的现实
